commit e784a5443d0bee380d1ad32055ad3075e3aa0995
Author: Chris Liddell <chris.liddell@artifex.com>
Date:   Mon May 2 14:32:18 2011 +0100

    Change error return to remove confusion over meaning.
    
    When we encounter a font whose charstring has been replaced with a PS
    procedure, we were returning FT_Err_Invalid_File_Format, and using that
    as a hint we should try to execute it as a PS procedure. This
    turns out to be problematic as it is also the error return generated by
    Freetype for an invalid charstring. In the case of an invalid charstring
    we should fall back to the notdef, not attempt to execute the object as
    Postscript.
    
    So, change the error return value that *we* generate, and subsequently
    check for, to FT_Err_Unknown_File_Format, which FT should never,
    normally, generate during glyph interpretation. This means, in this
    case, we correctly identify a failed attempt to interpret a charstring,
    and use the notdef fallback - instead of, eventually, throwing an
    error.
    
    Bug 692176.
    
    No cluster differences expected.

diff --git a/gs/psi/fapi_ft.c b/gs/psi/fapi_ft.c
index a420a84..f3c656a 100644
--- a/gs/psi/fapi_ft.c
+++ b/gs/psi/fapi_ft.c
@@ -227,7 +227,7 @@ get_fapi_glyph_data(FT_Incremental a_info, FT_UInt a_index, FT_Data *a_data)
        length = ff->get_glyph(ff, a_index, a_info->glyph_data, (ushort)a_info->glyph_data_length);
        if (length == -1) {
            ff->char_data = saved_char_data;
-           return FT_Err_Invalid_File_Format;
+           return FT_Err_Unknown_File_Format;
        }
 
        /* If the buffer was too small enlarge it and try again. */
@@ -246,7 +246,7 @@ get_fapi_glyph_data(FT_Incremental a_info, FT_UInt a_index, FT_Data *a_data)
             ff->char_data = saved_char_data;
             length = ff->get_glyph(ff, a_index, a_info->glyph_data, length);
             if (length == -1)
-                return FT_Err_Invalid_File_Format;
+                return FT_Err_Unknown_File_Format;
         }
 
         /* Set the returned pointer and length. */
@@ -435,7 +435,7 @@ load_glyph(FAPI_font *a_fapi_font, const FAPI_char_ref *a_char_ref,
         else {
             /* Current FreeType hinting for type 1 fonts is so poor we are actually better off without it (fewer files render incorrectly) (FT_LOAD_NO_HINTING) */
             ft_error = FT_Load_Glyph(ft_face, index, FT_LOAD_MONOCHROME | FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP | FT_LOAD_LINEAR_DESIGN);
-            if (ft_error == FT_Err_Invalid_File_Format) 
+            if (ft_error == FT_Err_Unknown_File_Format)
                 return index+1;
         }
     }
commit 6f6e28de040e17580fa2a92ce65368cd13ca9964
Author: Chris Liddell <chris.liddell@artifex.com>
Date:   Tue Feb 22 16:10:08 2011 +0000

    Tweak to allow compressed romfs to be built when we're configured
    to use the system's zlib rather than our own.
    
    As a side effect of this, freetype is now configured to use the
    same zlib instance as Ghostscript (instead of freetype's own
    subset of zlib sources).
    
    Bug 691986
    
    No cluster differences expected.
    
    git-svn-id: http://svn.ghostscript.com/ghostscript/trunk@12184 a1074d23-0009-0410-80fe-cf8c14f379e6

diff --git a/gs/base/lib.mak b/gs/base/lib.mak
index d97c3d4..44275b4 100644
--- a/gs/base/lib.mak
+++ b/gs/base/lib.mak
@@ -2823,10 +2823,14 @@
 
 # Define the ZLIB modules needed by mnkromfs here to factor it out of top makefiles
 # Also put the .h dependencies here for the same reason
-MKROMFS_ZLIB_OBJS=$(GLOBJ)compress.$(OBJ) $(GLOBJ)deflate.$(OBJ) \
+MKROMFS_ZLIB_OBJ_1=
+
+MKROMFS_ZLIB_OBJS_0=$(GLOBJ)compress.$(OBJ) $(GLOBJ)deflate.$(OBJ) \
 	$(GLOBJ)zutil.$(OBJ) $(GLOBJ)adler32.$(OBJ) $(GLOBJ)crc32.$(OBJ) \
 	$(GLOBJ)trees.$(OBJ)
 
+MKROMFS_ZLIB_OBJS=$(MKROMFS_ZLIB_OBJS_$(SHARE_ZLIB))
+
 MKROMFS_COMMON_DEPS=$(stdpre_h) $(stdint__h) $(gsiorom_h) $(arch_h)\
 	$(gsmemret_h) $(gsmalloc_h) $(gsstype_h) $(gp_h) $(time__h)
 
